____________________________

# Introduction to Celery
____________________________

# Celery is an asynchronous task queue/job queue system used in Django and other web frameworks to:
- handle tasks outside the request-response cycle.
- It allows you to offload time-consuming or resource-intensive tasks to be executed asynchronously.
- which can improve the performance and responsiveness of your web application.

[*] operates as a separate process or set of processes that interact with Django through a message broker.
____________________________

# Why Use Celery in Django?
____________________________



# Asynchronous Task Execution: 
____________________________

# Celery lets you run tasks in the background, which prevents your web application from being blocked 
while the task is being processed. For example:
sending an email, generating a report, or processing a large data set can be done asynchronously.

# Improved Performance: 
____________________________

# By offloading long-running tasks to Celery
your Django application can respond to user requests faster.
This is particularly important in web applications where users expect quick responses.

# Task Scheduling: 
____________________________

# Celery allows you to schedule tasks to run at specific times or intervals. 
For example, you might want to  :
run a cleanup task every night or send reminders at specific times.

# Retrying Failed Tasks: 
____________________________

# Celery has built-in support for retrying tasks that fail due to temporary issues 
such as : network problems or resource limitations.

# Scalability: 
____________________________

Celery is designed to work well in distributed environments, allowing you to :
# scale your task execution across multiple workers and even across multiple servers.


____________________________

# Problems Celery Solves
____________________________


# Long-running Tasks: 

Tasks that take a long time to complete can be moved to Celery, allowing your application to remain responsive.

# Time-sensitive Operations:

If you need to perform operations at specific intervals or at a certain time,
Celeryâ€™s task scheduling capabilities can handle this.

# Concurrent Processing: 

Celery allows you to process multiple tasks concurrently.
which can be crucial for applications that handle a high volume of requests.

# Error Handling: 

Celery can automatically retry failed tasks and provide detailed logging and error tracking

____________________________

# Example Use Cases
____________________________

# Sending Emails: Instead of blocking the user while an email is sent, you can queue the email to be sent in the background.

# Generating Reports: 

- For complex reports that take a long time to generate, Celery can handle the processing
in the background and notify the user when the report is ready.

# Data Processing: 

- For tasks like image processing, video transcoding, or data analysis, Celery can handle these processes asynchronously.
allowing your application to stay responsive.


____________________________

# How Celery Works
____________________________

Celery works by having a task queue where tasks are placed. 
These tasks are then picked up by worker processes that execute them.

- Basic Components:

[*] Tasks: The functions that you want to execute asynchronously.
[*] Workers: The processes that pick up and execute tasks from the queue.
[*] Brokers: The message brokers (e.g., RabbitMQ, Redis) that handle the communication 
between your Django application and Celery.

# Brokers

Role: Acts as the middleman between Django and Celery. 
It holds the tasks that need to be processed and allows Celery workers to retrieve these tasks.
__________________________________________________________________________________________________


________________________________________________________

# Scenario: Sending a Welcome Email to New Users
________________________________________________________

When a user signs up on your website, you want to send them a welcome email. 
Sending this email could take some time, especially if the email service is slow. 
Instead of making the user wait, you can use Celery to send the email in the background.

# Step-by-Step Representation

# 1 - User Signs Up

[*] User Action: A new user fills out the sign-up form and clicks "Submit."
[*] Django: Receives the request and creates the user in the database.
[*] Task: Send a welcome email.

[User] ---> (HTTP Request) ---> [Django Server] ---> [Create User in DB]
                                                |
                                                V
                                            [Send Email Task]

# 2 - Sending the Email (Without Celery)

Without Celery, the email sending is part of the request-response cycle. This could cause delays.

[User] ---> [Django Server] ---> [Create User in DB] ---> [Send Email] ---> [Response to User]

[*] Problem: The user has to wait until the email is sent, causing a delay in the response.

# 3 - Sending the Email (With Celery)

With Celery, the email task is offloaded to a background worker.
The user doesn't have to wait for the email to be sent.

[User] ---> [Django Server] ---> [Create User in DB] ---> [Enqueue Email Task in Celery]
                                                |
                                                V
                                           [Return Response to User]

                  [Celery Worker] <--- [Email Task] ---> [Send Email]

# Enqueue Email Task in Celery: 

- Django adds the task of sending the email to the Celery task queue.

# Return Response to User: 

- The server immediately returns a response to the user saying "Registration Successful."

# Celery Worker: 

- A separate process (worker) picks up the email task from the queue and sends the email in the background.


# 4 - Task Execution by Celery Worker

# Celery Worker: The worker checks the queue and finds the "Send Email" task.
# Task Execution: The worker sends the email while Django continues handling other requests.

[Celery Worker] ---> [Send Email] ---> [Email Sent Successfully]

____________________________

# Code Example : 
____________________________

1. Define the Celery Task

________________________________________________________

# tasks.py

from celery import shared_task
from django.core.mail import send_mail

@shared_task
def send_welcome_email(user_email):
    send_mail(
        'Welcome to Our Service',
        'Thanks for signing up!',
        'from@example.com',
        [user_email],
        fail_silently=False,
    )

________________________________________________________


2. Trigger the Celery Task in the Django View

________________________________________________________

# views.py

from django.shortcuts import render
from .models import User
from .tasks import send_welcome_email

def signup_view(request):
    if request.method == 'POST':
        # Assume form processing and user creation happens here
        user_email = 'newuser@example.com'
        
        # Trigger the Celery task
        send_welcome_email.delay(user_email)
        
        return render(request, 'registration_success.html')

________________________________________________________

3. Celery Worker Setup

You would typically start the Celery worker with:

celery -A your_project_name worker --loglevel=info


________________________________________________________

# What is a Task Queue?

A task queue is a system used to manage tasks that need to be processed. 
Tasks are queued up, and workers pick up these tasks from the queue and process them. 
This allows tasks to be executed asynchronously and outside the main request-response cycle of an application.

# Key Components

    Tasks: The units of work that need to be done (e.g., sending an email, processing an image).
    Queue: A waiting line where tasks are placed until a worker is ready to process them.
    Workers: Processes that pick up tasks from the queue and execute them.
    Broker: A message broker (like RabbitMQ or Redis) that manages the task queue 
    and the communication between the Django application and the workers.

# Task Creation

    Action: A task is created in the application, for example, sending an email.
    Django: Django application pushes the task into the queue.

[Django App] ---> [Task Queue]

# Task Queue

    Queue: The task sits in the queue, waiting to be picked up by an available worker.

    [Task Queue] ---> [Task 1]
                      [Task 2]
                      [Task 3]


# Worker Processes Task

    Workers: Workers are processes that continuously poll the task queue to check if there are any tasks available.
    Task Execution: Once a worker finds a task, it picks it up and executes it.

[Worker 1] <--- [Task Queue] ---> [Task 1]
[Worker 2] <--- [Task Queue] ---> [Task 2]
[Worker 3] <--- [Task Queue] ---> [Task 3]

# Task Completion

    Completion: After processing, the worker marks the task as completed and may 
    return a result or just finish execution.

    [Worker 1] ---> [Task Completed]
    [Worker 2] ---> [Task Completed]


















